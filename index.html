<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <meta name="color-scheme" content="light dark" />
    <title>中国象棋</title>
    <style>
        :root {
            color-scheme: light dark;

            --fg-color: #212529;
            --bg-color: #f8f9fa;
            --red-piece-color: #d32f2f;
            --path-color: #1565c0;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --fg-color: #f8f9fa;
                --bg-color: #212529;
                --red-piece-color: #ff5252;
                --path-color: #64b5f6;
            }
        }

        body {
            color: var(--fg-color);
            background-color: var(--bg-color);

            align-items: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin: 0;
            min-height: 100vh;
        }

        .container {
            align-items: center;
            display: flex;
            gap: 8px;
        }

        #chessboard {
            border: 1px solid var(--fg-color);
            cursor: default;
        }

        .controls {
            align-items: center;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        textarea {
            font-family: monospace;
            height: 300px;
            resize: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <svg id="chessboard"></svg>
        <div class="controls">
            <textarea id="pathInput" placeholder="(2,1)-(3,3)&#10;(3,3)-(5,2)-(7,3)"></textarea>
            <div class="buttons">
                <button id="drawPathsBtn">绘制路径</button>
                <button id="movePiecesBtn">移动棋子</button>
            </div>
            <div style="text-align: center;">
                <small>
                    单击选择棋子<br>
                    再选目标点移动<br>
                    双击移除棋子
                </small>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            NUM_FILES: 9,
            NUM_RANKS: 10,
            PIECE_SIZE: 36
        };
        const FONT_SIZE = CONFIG.PIECE_SIZE * 0.76;
        const CELL_SIZE = CONFIG.PIECE_SIZE * 1.15;
        const VERTICAL_MARGIN = CONFIG.PIECE_SIZE;
        const BOARD_WIDTH = (CONFIG.NUM_FILES - 1) * CELL_SIZE;
        const BOARD_HEIGHT = (CONFIG.NUM_RANKS - 1) * CELL_SIZE;
        const SVG_SIZE = BOARD_HEIGHT + VERTICAL_MARGIN * 2;
        const HORIZONTAL_MARGIN = (SVG_SIZE - BOARD_WIDTH) / 2;

        const coordinate = {
            toSVGPos(col, row) {
                return {
                    x: HORIZONTAL_MARGIN + (CONFIG.NUM_FILES - col) * CELL_SIZE,
                    y: VERTICAL_MARGIN + (CONFIG.NUM_RANKS - row) * CELL_SIZE
                };
            },
            toBoardPos(x, y) {
                const col = CONFIG.NUM_FILES - Math.round((x - HORIZONTAL_MARGIN) / CELL_SIZE);
                const row = CONFIG.NUM_RANKS - Math.round((y - VERTICAL_MARGIN) / CELL_SIZE);
                return { col, row };
            },
            isValidPosition(col, row) {
                return col >= 1 && col <= CONFIG.NUM_FILES && row >= 1 && row <= CONFIG.NUM_RANKS;
            }
        };

        const PIECE_TEMPLATES = {
            black: [
                { cols: [1, 2, 3, 4, 5, 6, 7, 8, 9], row: 10, names: ["车", "马", "象", "士", "将", "士", "象", "马", "车"] },
                { cols: [2, 8], row: 8, names: ["炮", "炮"] },
                { cols: [1, 3, 5, 7, 9], row: 7, names: ["卒", "卒", "卒", "卒", "卒"] }
            ],
            red: [
                { cols: [1, 2, 3, 4, 5, 6, 7, 8, 9], row: 1, names: ["车", "马", "相", "仕", "帅", "仕", "相", "马", "车"] },
                { cols: [2, 8], row: 3, names: ["炮", "炮"] },
                { cols: [1, 3, 5, 7, 9], row: 4, names: ["兵", "兵", "兵", "兵", "兵"] }
            ]
        };

        let pieces = [];
        let currentPaths = [];
        let selectedPiece = null;

        function el(tag, attributes = {}) {
            const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, String(value));
            });
            return element;
        }

        function drawGrid() {
            const gridLayer = el('g');

            for (let i = 0; i < CONFIG.NUM_RANKS; i++) {
                const y = VERTICAL_MARGIN + i * CELL_SIZE;
                gridLayer.appendChild(el('line', {
                    x1: HORIZONTAL_MARGIN, y1: y,
                    x2: HORIZONTAL_MARGIN + BOARD_WIDTH, y2: y,
                    stroke: 'var(--fg-color)',
                    'stroke-width': '1'
                }));
            }

            for (let i = 0; i < CONFIG.NUM_FILES; i++) {
                const x = HORIZONTAL_MARGIN + i * CELL_SIZE;
                gridLayer.appendChild(el('line', {
                    x1: x, y1: VERTICAL_MARGIN,
                    x2: x, y2: VERTICAL_MARGIN + BOARD_HEIGHT,
                    stroke: 'var(--fg-color)',
                    'stroke-width': '1'
                }));
            }

            const drawDiagonal = (x1, y1, x2, y2) => {
                gridLayer.appendChild(el('line', { x1, y1, x2, y2, stroke: 'var(--fg-color)', 'stroke-width': '1' }));
            };

            const diagonals = [
                { c1: 4, r1: 8, c2: 6, r2: 10 },
                { c1: 4, r1: 10, c2: 6, r2: 8 },
                { c1: 4, r1: 1, c2: 6, r2: 3 },
                { c1: 4, r1: 3, c2: 6, r2: 1 },
            ];

            diagonals.forEach(d => {
                const p1 = coordinate.toSVGPos(d.c1, d.r1);
                const p2 = coordinate.toSVGPos(d.c2, d.r2);
                drawDiagonal(p1.x, p1.y, p2.x, p2.y);
            });

            return gridLayer;
        }

        function drawRiver() {
            const riverLayer = el('g');
            const riverY = VERTICAL_MARGIN + 4 * CELL_SIZE;

            riverLayer.appendChild(el('rect', {
                x: HORIZONTAL_MARGIN,
                y: riverY,
                width: BOARD_WIDTH,
                height: CELL_SIZE,
                fill: 'var(--bg-color)'
            }));

            const riverText = el('text', {
                x: HORIZONTAL_MARGIN + BOARD_WIDTH / 2,
                y: riverY + CELL_SIZE / 2,
                fill: 'var(--fg-color)',
                'font-size': FONT_SIZE,
                'dominant-baseline': 'middle',
                'text-anchor': 'middle'
            });

            riverText.textContent = "楚 河 汉 界";
            riverLayer.appendChild(riverText);

            return riverLayer;
        }

        function drawDecorations() {
            const decorationLayer = el('g');
            const L_LENGTH = CELL_SIZE / 5;
            const OFFSET = 4;

            const DECORATION_ROWS = [
                { row: 8, cols: [2, 8] },
                { row: 7, cols: [1, 3, 5, 7, 9] },
                { row: 4, cols: [1, 3, 5, 7, 9] },
                { row: 3, cols: [2, 8] }
            ];

            DECORATION_ROWS.forEach(({ row, cols }) => {
                cols.forEach(col => {
                    const svgPos = coordinate.toSVGPos(col, row);
                    const x = svgPos.x;
                    const y = svgPos.y;

                    const corners = [
                        { dx: -OFFSET, dy: -OFFSET, dirX: -1, dirY: -1 },
                        { dx: OFFSET, dy: -OFFSET, dirX: 1, dirY: -1 },
                        { dx: -OFFSET, dy: OFFSET, dirX: -1, dirY: 1 },
                        { dx: OFFSET, dy: OFFSET, dirX: 1, dirY: 1 }
                    ];

                    corners.forEach(({ dx, dy, dirX, dirY }) => {
                        if (col === 1 && dirX === 1) return;
                        if (col === 9 && dirX === -1) return;

                        decorationLayer.appendChild(el('line', {
                            x1: x + dx,
                            y1: y + dy,
                            x2: x + dx,
                            y2: y + dy + dirY * L_LENGTH,
                            stroke: 'var(--fg-color)',
                            'stroke-width': '1'
                        }));
                        decorationLayer.appendChild(el('line', {
                            x1: x + dx,
                            y1: y + dy,
                            x2: x + dx + dirX * L_LENGTH,
                            y2: y + dy,
                            stroke: 'var(--fg-color)',
                            'stroke-width': '1'
                        }));
                    });
                });
            });

            return decorationLayer;
        }

        function initializePieces() {
            pieces = [];

            Object.entries(PIECE_TEMPLATES).forEach(([color, templates]) => {
                templates.forEach(template => {
                    template.cols.forEach((col, index) => {
                        pieces.push({
                            col,
                            row: template.row,
                            name: template.names[index],
                            color
                        });
                    });
                });
            });
        }

        function drawPieces() {
            const pieceLayer = document.getElementById('pieces');
            pieceLayer.innerHTML = '';

            pieces.forEach(piece => {
                const pos = coordinate.toSVGPos(piece.col, piece.row);
                const pieceId = `${piece.col}-${piece.row}`;

                const g = el('g', {
                    'data-pos': `${piece.col},${piece.row}`,
                    'data-piece-id': pieceId,
                    transform: `translate(${pos.x}, ${pos.y})`
                });

                g.appendChild(el('circle', {
                    r: CONFIG.PIECE_SIZE / 2,
                    fill: 'var(--bg-color)',
                    stroke: 'var(--fg-color)',
                    'stroke-width': '1'
                }));

                const text = el('text', {
                    fill: piece.color === 'black' ? 'var(--fg-color)' : 'var(--red-piece-color)',
                    'font-size': FONT_SIZE,
                    'dominant-baseline': 'middle',
                    'text-anchor': 'middle'
                });

                text.textContent = piece.name;
                g.appendChild(text);
                g.addEventListener('dblclick', (e) => handlePieceDoubleClick(e, piece));
                g.addEventListener('click', (e) => handlePieceClick(e, piece));
                pieceLayer.appendChild(g);
            });
        }

        function handlePieceDoubleClick(e, piece) {
            e.stopPropagation();
            const idx = pieces.findIndex(p => p.col === piece.col && p.row === piece.row);

            if (idx !== -1) {
                pieces.splice(idx, 1);
                e.target.closest('g').remove();
                if (selectedPiece && selectedPiece.col === piece.col && selectedPiece.row === piece.row) {
                    selectedPiece = null;
                }
            }
        }

        function handlePieceClick(e, piece) {
            e.stopPropagation();
            const pieceEl = document.querySelector(`#pieces g[data-piece-id="${piece.col}-${piece.row}"]`);

            if (selectedPiece && selectedPiece.col === piece.col && selectedPiece.row === piece.row) {
                deselectPiece(pieceEl);
                selectedPiece = null;
            } else {
                if (selectedPiece) {
                    const oldEl = document.querySelector(`#pieces g[data-piece-id="${selectedPiece.col}-${selectedPiece.row}"]`);
                    if (oldEl) deselectPiece(oldEl);
                }
                selectPiece(pieceEl);
                selectedPiece = piece;
            }
        }

        function handleBoardClick(e) {
            const svg = document.getElementById('chessboard');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            const { col, row } = coordinate.toBoardPos(svgP.x, svgP.y);

            if (!coordinate.isValidPosition(col, row)) return;

            const clickedPiece = pieces.find(p => p.col === col && p.row === row);
            if (clickedPiece) {
                handlePieceClick(e, clickedPiece);
            } else if (selectedPiece) {
                moveSelectedPieceTo(col, row);
            }
        }

        function selectPiece(g) {
            const circle = g.querySelector('circle');
            circle.setAttribute('stroke-width', '2');
        }

        function deselectPiece(g) {
            const circle = g.querySelector('circle');
            circle.setAttribute('stroke-width', '1');
        }

        function movePiece(fromCol, fromRow, toCol, toRow) {
            if (!coordinate.isValidPosition(toCol, toRow)) return false;
            if (hasPieceAt(toCol, toRow)) return false;

            const pieceIndex = pieces.findIndex(p => p.col === fromCol && p.row === fromRow);
            if (pieceIndex === -1) return false;

            const piece = pieces[pieceIndex];
            const oldId = `${fromCol}-${fromRow}`;
            const newId = `${toCol}-${toRow}`;
            piece.col = toCol;
            piece.row = toRow;

            const pieceEl = document.querySelector(`#pieces g[data-piece-id="${oldId}"]`);

            pieceEl.dataset.pos = `${toCol},${toRow}`;
            pieceEl.dataset.pieceId = newId;
            const newPos = coordinate.toSVGPos(toCol, toRow);
            pieceEl.setAttribute('transform', `translate(${newPos.x}, ${newPos.y})`);

            return true;
        }

        function moveSelectedPieceTo(col, row) {
            if (!selectedPiece) return;
            const success = movePiece(selectedPiece.col, selectedPiece.row, col, row);

            if (success) {
                const g = document.querySelector(`#pieces g[data-piece-id="${col}-${row}"]`);
                if (g) deselectPiece(g);
                selectedPiece = null;
            }
        }

        function parsePaths(input) {
            const paths = [];
            const pathMatches = input.match(/\(\s*\d+\s*,\s*\d+\s*\)(?:\s*-\s*\(\s*\d+\s*,\s*\d+\s*\))+/g) || [];

            for (const pathStr of pathMatches) {
                const points = pathStr.match(/\d+/g).map(Number);
                for (let i = 0; i < points.length - 2; i += 2) {
                    const c1 = points[i], r1 = points[i + 1];
                    const c2 = points[i + 2], r2 = points[i + 3];
                    if (coordinate.isValidPosition(c1, r1) && coordinate.isValidPosition(c2, r2)) {
                        paths.push({ c1, r1, c2, r2 });
                    }
                }
            }

            return paths;
        }

        function drawPaths() {
            const layer = document.getElementById('paths');
            layer.innerHTML = '';
            currentPaths = parsePaths(document.getElementById('pathInput').value);

            currentPaths.forEach(path => {
                const p1 = coordinate.toSVGPos(path.c1, path.r1);
                const p2 = coordinate.toSVGPos(path.c2, path.r2);
                layer.appendChild(el('line', {
                    x1: p1.x, y1: p1.y,
                    x2: p2.x, y2: p2.y,
                    stroke: 'var(--path-color)',
                    'stroke-width': '2',
                    'stroke-dasharray': '5,5'
                }));
            });
        }

        function movePieces() {
            const moves = parsePaths(document.getElementById('pathInput').value);
            for (const move of moves) {
                if (!movePiece(move.c1, move.r1, move.c2, move.r2)) break;
            }
        }

        function hasPieceAt(col, row) {
            return pieces.some(p => p.col === col && p.row === row);
        }

        function initChessboard() {
            const svg = document.getElementById('chessboard');
            svg.setAttribute('width', SVG_SIZE);
            svg.setAttribute('height', SVG_SIZE);
            svg.innerHTML = '';

            const layers = {
                grid: drawGrid(),
                river: drawRiver(),
                decorations: drawDecorations(),
                paths: el('g', { id: 'paths' }),
                pieces: el('g', { id: 'pieces' })
            };

            Object.values(layers).forEach(layer => svg.appendChild(layer));

            initializePieces();
            drawPieces();
            svg.addEventListener('click', handleBoardClick);
            document.getElementById('drawPathsBtn').addEventListener('click', drawPaths);
            document.getElementById('movePiecesBtn').addEventListener('click', movePieces);
        }

        initChessboard();
    </script>
</body>

</html>
