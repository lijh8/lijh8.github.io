<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <title>中国象棋</title>
  <style>
    body {
      align-items: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
    }

    .container {
      align-items: center;
      display: flex;
      gap: 8px;
    }

    #chessboard {
      border: 1px solid;
      cursor: default;
    }

    .controls {
      align-items: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    textarea {
      font-family: monospace;
      height: 200px;
      resize: none;
    }
  </style>
</head>

<body>
  <div class="container">
    <svg id="chessboard"></svg>
    <div class="controls">
      <textarea id="pathInput" placeholder="(2,1)-(3,3)&#10;(3,3)-(5,2)-(7,3)"></textarea>
      <div>
        <button onclick="drawPaths()">绘制路径</button>
        <button onclick="movePieces()">移动棋子</button>
      </div>
      <div>
        <small style="text-align: center; display: block;">
          鼠标单击选择棋子 <br>
          再选目标点移动<br>
          双击移除棋子
        </small>
      </div>
    </div>
  </div>

  <script>

    const NUM_FILES = 9;
    const NUM_RANKS = 10;
    const FONT_SIZE = 20;
    const RADIUS = FONT_SIZE * 0.65;
    const CELL_SIZE = FONT_SIZE * 1.5;
    const VERTICAL_MARGIN = RADIUS * 2;
    const SVG_SIZE = (NUM_RANKS - 1) * CELL_SIZE + VERTICAL_MARGIN * 2;
    const BOARD_WIDTH = (NUM_FILES - 1) * CELL_SIZE;
    const BOARD_HEIGHT = (NUM_RANKS - 1) * CELL_SIZE;
    const HORIZONTAL_MARGIN = (SVG_SIZE - BOARD_WIDTH) / 2;

    function el(tag, attributes = {}) {
      const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
      Object.entries(attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });
      return element;
    }

    const PIECE_TEMPLATES = {
      black: [
        { cols: [1, 2, 3, 4, 5, 6, 7, 8, 9], row: 10, names: ["车", "马", "象", "士", "将", "士", "象", "马", "车"] },
        { cols: [2, 8], row: 8, names: ["炮", "炮"] },
        { cols: [1, 3, 5, 7, 9], row: 7, names: ["卒", "卒", "卒", "卒", "卒"] }
      ],
      red: [
        { cols: [1, 2, 3, 4, 5, 6, 7, 8, 9], row: 1, names: ["车", "马", "相", "仕", "帅", "仕", "相", "马", "车"] },
        { cols: [2, 8], row: 3, names: ["炮", "炮"] },
        { cols: [1, 3, 5, 7, 9], row: 4, names: ["兵", "兵", "兵", "兵", "兵"] }
      ]
    };

    let pieces = [];

    Object.entries(PIECE_TEMPLATES).forEach(([color, templates]) => {
      templates.forEach(template => {
        template.cols.forEach((col, index) => {
          pieces.push({
            col,
            row: template.row,
            name: template.names[index],
            color
          });
        });
      });
    });

    let currentPaths = [];
    let selectedPiece = null;

    function toSVGPos(col, row) {
      return {
        x: HORIZONTAL_MARGIN + (NUM_FILES - col) * CELL_SIZE,
        y: VERTICAL_MARGIN + (NUM_RANKS - row) * CELL_SIZE
      };
    }

    function toBoardPos(x, y) {
      const col = NUM_FILES - Math.round((x - HORIZONTAL_MARGIN) / CELL_SIZE);
      const row = NUM_RANKS - Math.round((y - VERTICAL_MARGIN) / CELL_SIZE);
      return { col, row };
    }

    function parsePaths(input) {
      const paths = [];
      const pathMatches = input.match(/\(\s*\d+\s*,\s*\d+\s*\)(?:\s*-\s*\(\s*\d+\s*,\s*\d+\s*\))+/g) || [];
      for (const pathStr of pathMatches) {
        const points = pathStr.match(/\d+/g).map(Number);
        for (let i = 0; i < points.length - 2; i += 2) {
          const c1 = points[i], r1 = points[i + 1];
          const c2 = points[i + 2], r2 = points[i + 3];
          if (c1 >= 1 && c1 <= NUM_FILES && r1 >= 1 && r1 <= NUM_RANKS &&
            c2 >= 1 && c2 <= NUM_FILES && r2 >= 1 && r2 <= NUM_RANKS) {
            paths.push({ c1, r1, c2, r2 });
          }
        }
      }
      return paths;
    }

    function initChessboard() {
      const svg = document.getElementById('chessboard');
      svg.setAttribute('width', SVG_SIZE);
      svg.setAttribute('height', SVG_SIZE);
      svg.innerHTML = '';

      const gridLayer = el('g', { id: 'gridLayer' });
      const riverLayer = el('g', { id: 'riverLayer' });
      const pathLayer = el('g', { id: 'paths' });
      const pieceLayer = el('g', { id: 'pieces' });

      for (let i = 0; i < NUM_FILES; i++) {
        const x = HORIZONTAL_MARGIN + i * CELL_SIZE;
        gridLayer.appendChild(el('line', {
          x1: x, y1: VERTICAL_MARGIN,
          x2: x, y2: VERTICAL_MARGIN + BOARD_HEIGHT,
          stroke: 'CanvasText'
        }));
      }

      for (let i = 0; i < NUM_RANKS; i++) {
        const y = VERTICAL_MARGIN + i * CELL_SIZE;
        gridLayer.appendChild(el('line', {
          x1: HORIZONTAL_MARGIN, y1: y,
          x2: HORIZONTAL_MARGIN + BOARD_WIDTH, y2: y,
          stroke: 'CanvasText'
        }));
      }

      const addDiag = (x1, y1, x2, y2) => gridLayer.appendChild(el('line', { x1, y1, x2, y2, stroke: 'CanvasText' }));
      const x3 = HORIZONTAL_MARGIN + 3 * CELL_SIZE;
      const x5 = HORIZONTAL_MARGIN + 5 * CELL_SIZE;
      const y0 = VERTICAL_MARGIN;
      const y2 = VERTICAL_MARGIN + 2 * CELL_SIZE;
      const y7 = VERTICAL_MARGIN + 7 * CELL_SIZE;
      const y9 = VERTICAL_MARGIN + 9 * CELL_SIZE;
      addDiag(x3, y0, x5, y2);
      addDiag(x5, y0, x3, y2);
      addDiag(x3, y7, x5, y9);
      addDiag(x5, y7, x3, y9);

      svg.appendChild(gridLayer);

      const riverY = VERTICAL_MARGIN + 4 * CELL_SIZE;
      riverLayer.appendChild(el('rect', {
        x: HORIZONTAL_MARGIN,
        y: riverY,
        width: BOARD_WIDTH,
        height: CELL_SIZE,
        fill: 'Canvas'
      }));
      const riverText = el('text', {
        x: HORIZONTAL_MARGIN + BOARD_WIDTH / 2,
        y: riverY + CELL_SIZE / 2,
        'font-size': FONT_SIZE,
        'text-anchor': 'middle',
        'dominant-baseline': 'middle',
        fill: 'CanvasText'
      });
      riverText.textContent = "楚 河 汉 界";
      riverLayer.appendChild(riverText);
      svg.appendChild(riverLayer);
      svg.appendChild(pathLayer);
      svg.appendChild(pieceLayer);

      drawPieces();
      svg.addEventListener('click', handleBoardClick);
    }

    function drawPieces() {
      const pieceLayer = document.getElementById('pieces');
      pieceLayer.innerHTML = '';

      pieces.forEach(p => {
        const pos = toSVGPos(p.col, p.row);
        const g = el('g', {
          'data-pos': `${p.col},${p.row}`,
          'data-piece-id': `${p.col}-${p.row}`,
          transform: `translate(${pos.x}, ${pos.y})`
        });

        g.appendChild(el('circle', {
          r: RADIUS,
          fill: 'Canvas',
          stroke: 'CanvasText',
          'stroke-width': '1'
        }));

        const text = el('text', {
          'font-size': FONT_SIZE,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          fill: p.color === 'black' ? 'CanvasText' : p.color
        });
        text.textContent = p.name;
        g.appendChild(text);

        g.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const idx = pieces.findIndex(x => x.col === p.col && x.row === p.row);
          if (idx !== -1) pieces.splice(idx, 1);
          g.remove();
          if (selectedPiece && selectedPiece.col === p.col && selectedPiece.row === p.row) {
            selectedPiece = null;
          }
        });

        g.addEventListener('click', (e) => {
          e.stopPropagation();
          handlePieceClick(p);
        });

        pieceLayer.appendChild(g);
      });
    }

    function handleBoardClick(e) {
      const svg = document.getElementById('chessboard');
      const pt = svg.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
      const boardPos = toBoardPos(svgP.x, svgP.y);

      if (boardPos.col < 1 || boardPos.col > NUM_FILES || boardPos.row < 1 || boardPos.row > NUM_RANKS) return;

      const clicked = pieces.find(p => p.col === boardPos.col && p.row === boardPos.row);
      if (clicked) {
        handlePieceClick(clicked);
      } else {
        handleEmptyClick(boardPos);
      }
    }

    function handlePieceClick(piece) {
      const el = document.querySelector(`#pieces g[data-piece-id="${piece.col}-${piece.row}"]`);
      if (!el) return;

      if (selectedPiece && selectedPiece.col === piece.col && selectedPiece.row === piece.row) {
        deselectPiece(el);
        selectedPiece = null;
      } else {
        if (selectedPiece) {
          const oldEl = document.querySelector(`#pieces g[data-piece-id="${selectedPiece.col}-${selectedPiece.row}"]`);
          if (oldEl) deselectPiece(oldEl);
        }
        selectPiece(el);
        selectedPiece = piece;
      }
    }

    function handleEmptyClick(pos) {
      if (selectedPiece) {
        moveSelectedPieceTo(pos.col, pos.row);
      }
    }

    function selectPiece(g) {
      g.querySelector('circle').setAttribute('stroke', 'LinkText');
      g.querySelector('circle').setAttribute('stroke-width', '2');
    }

    function deselectPiece(g) {
      g.querySelector('circle').setAttribute('stroke', 'CanvasText');
      g.querySelector('circle').setAttribute('stroke-width', '1');
    }

    function movePiece(fromCol, fromRow, toCol, toRow) {
      if (toCol < 1 || toCol > NUM_FILES || toRow < 1 || toRow > NUM_RANKS) {
        console.warn(`目标位置 (${toCol},${toRow}) 超出棋盘！`);
        return false;
      }
      if (hasPieceAt(toCol, toRow)) {
        console.log(`目标位置 (${toCol},${toRow}) 已有棋子！`);
        return false;
      }
      const idx = pieces.findIndex(p => p.col === fromCol && p.row === fromRow);
      if (idx === -1) {
        console.warn(`源位置 (${fromCol},${fromRow}) 无棋子！`);
        return false;
      }

      const piece = pieces[idx];
      const oldId = `${fromCol}-${fromRow}`;
      const newId = `${toCol}-${toRow}`;

      piece.col = toCol;
      piece.row = toRow;

      const g = document.querySelector(`#pieces g[data-piece-id="${oldId}"]`);
      if (!g) return false;

      g.dataset.pos = `${toCol},${toRow}`;
      g.dataset.pieceId = newId;
      const newPos = toSVGPos(toCol, toRow);
      g.setAttribute('transform', `translate(${newPos.x}, ${newPos.y})`);

      return true;
    }

    function moveSelectedPieceTo(col, row) {
      if (!selectedPiece) return;
      const success = movePiece(selectedPiece.col, selectedPiece.row, col, row);
      if (success) {
        const g = document.querySelector(`#pieces g[data-piece-id="${col}-${row}"]`);
        if (g) deselectPiece(g);
        selectedPiece = null;
      }
    }

    function movePieces() {
      const moves = parsePaths(document.getElementById('pathInput').value);
      for (const m of moves) {
        if (!movePiece(m.c1, m.r1, m.c2, m.r2)) break;
      }
    }

    function drawPaths() {
      const layer = document.getElementById('paths');
      layer.innerHTML = '';
      currentPaths = parsePaths(document.getElementById('pathInput').value);
      currentPaths.forEach(p => {
        const p1 = toSVGPos(p.c1, p.r1);
        const p2 = toSVGPos(p.c2, p.r2);
        layer.appendChild(el('line', {
          x1: p1.x, y1: p1.y,
          x2: p2.x, y2: p2.y,
          stroke: 'LinkText',
          'stroke-dasharray': '5,5',
          'stroke-width': '2'
        }));
      });
    }

    function hasPieceAt(col, row) {
      return pieces.some(p => p.col === col && p.row === row);
    }

    initChessboard();
  </script>
</body>

</html>
