<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <title>中国象棋</title>
  <style>
    /*
    https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme
    https://developer.mozilla.org/en-US/docs/Web/CSS/system-color
    */

    :root {
      color-scheme: light dark;
    }

    /*
    - the default background-color is too dark in dark mode.
    - the system color Field is good in both light and dark mode.
    - use Field as background color and FieldText as foreground color for
      other non-builtin controls.
    - LinkText is also good color for other purpose on Field background color.
    */
    body {
      align-items: center;
      display: flex;
      background-color: Field;
      flex-direction: column;
      justify-content: center;
      min-height: 100vh;
    }

    .container {
      align-items: center;
      display: flex;
      gap: 8px;
    }

    #chessboard {
      border: 1px solid;
      cursor: default;
    }

    .controls {
      align-items: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    textarea {
      border: 1px solid;
      font-family: monospace;
      height: 230px;
      resize: none;
    }
  </style>
</head>

<body>
  <div class="container">
    <svg id="chessboard"></svg>
    <div class="controls">
      <textarea id="pathInput" placeholder="(2,1)-(3,3)&#10;(3,3)-(5,2)-(7,3)"></textarea>
      <div>
        <button onclick="drawPaths()">绘制路径</button>
        <button onclick="movePieces()">移动棋子</button>
      </div>
      <div>
        <small>鼠标左键双击棋子可以移除棋子</small>
      </div>
    </div>
  </div>

  <script>
    // 棋盘常量
    const NUM_FILES = 9;
    const NUM_RANKS = 10;
    const FONT_SIZE = 20;
    const RADIUS = FONT_SIZE * 0.65;
    const CELL_SIZE = FONT_SIZE * 1.5;
    const VERTICAL_MARGIN = RADIUS * 2;
    const SVG_SIZE = (NUM_RANKS - 1) * CELL_SIZE + VERTICAL_MARGIN * 2;
    const BOARD_WIDTH = (NUM_FILES - 1) * CELL_SIZE;
    const BOARD_HEIGHT = (NUM_RANKS - 1) * CELL_SIZE;
    const HORIZONTAL_MARGIN = (SVG_SIZE - BOARD_WIDTH) / 2;

    // SVG 元素创建辅助函数
    function el(tag, attributes = {}) {
      const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
      Object.entries(attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });
      return element;
    }

    // 存储棋子状态
    const PIECE_TEMPLATES = {
      black: [
        { cols: [1, 2, 3, 4, 5, 6, 7, 8, 9], row: 10, names: ["车", "马", "象", "士", "将", "士", "象", "马", "车"] },
        { cols: [2, 8], row: 8, names: ["炮", "炮"] },
        { cols: [1, 3, 5, 7, 9], row: 7, names: ["卒", "卒", "卒", "卒", "卒"] }
      ],
      red: [
        { cols: [1, 2, 3, 4, 5, 6, 7, 8, 9], row: 1, names: ["车", "马", "相", "仕", "帅", "仕", "相", "马", "车"] },
        { cols: [2, 8], row: 3, names: ["炮", "炮"] },
        { cols: [1, 3, 5, 7, 9], row: 4, names: ["兵", "兵", "兵", "兵", "兵"] }
      ]
    };

    let pieces = [];

    Object.entries(PIECE_TEMPLATES).forEach(([color, templates]) => {
      templates.forEach(template => {
        template.cols.forEach((col, index) => {
          pieces.push({
            col,
            row: template.row,
            name: template.names[index],
            color
          });
        });
      });
    });

    // 存储路径
    let currentPaths = [];

    // 存储选中的棋子
    let selectedPiece = null;

    // 从棋盘坐标转换为SVG坐标
    function toSVGPos(col, row) {
      return {
        x: HORIZONTAL_MARGIN + (NUM_FILES - col) * CELL_SIZE,
        y: VERTICAL_MARGIN + (NUM_RANKS - row) * CELL_SIZE
      };
    }

    // 从SVG坐标转换为棋盘坐标
    function fromSVGPos(x, y) {
      const col = NUM_FILES - Math.round((x - HORIZONTAL_MARGIN) / CELL_SIZE);
      const row = NUM_RANKS - Math.round((y - VERTICAL_MARGIN) / CELL_SIZE);
      return { col, row };
    }

    // 解析路径
    function parsePaths(input) {
      const paths = [];
      const pathMatches = input.match(/\(\s*\d+\s*,\s*\d+\s*\)(?:\s*-\s*\(\s*\d+\s*,\s*\d+\s*\))+/g) || [];

      for (const pathStr of pathMatches) {
        const points = pathStr.match(/\d+/g).map(Number);

        for (let i = 0; i < points.length - 2; i += 2) {
          const c1 = points[i], r1 = points[i + 1];
          const c2 = points[i + 2], r2 = points[i + 3];

          if (c1 >= 1 && c1 <= NUM_FILES && r1 >= 1 && r1 <= NUM_RANKS &&
            c2 >= 1 && c2 <= NUM_FILES && r2 >= 1 && r2 <= NUM_RANKS) {
            paths.push({ c1, r1, c2, r2 });
          }
        }
      }

      return paths;
    }

    // 初始化棋盘
    function initChessboard() {
      const svg = document.getElementById('chessboard');
      svg.setAttribute('width', SVG_SIZE);
      svg.setAttribute('height', SVG_SIZE);
      svg.innerHTML = '';

      // 创建图层
      const gridLayer = el('g', { id: 'gridLayer' });
      const riverLayer = el('g', { id: 'riverLayer' });
      const pathLayer = el('g', { id: 'paths' });
      const pieceLayer = el('g', { id: 'pieces' });

      // 绘制竖线
      for (let i = 0; i < NUM_FILES; i++) {
        const x = HORIZONTAL_MARGIN + i * CELL_SIZE;
        const line = el('line', {
          x1: x,
          y1: VERTICAL_MARGIN,
          x2: x,
          y2: VERTICAL_MARGIN + BOARD_HEIGHT,
          stroke: 'ButtonBorder'
        });
        gridLayer.appendChild(line);
      }

      // 绘制横线
      for (let i = 0; i < NUM_RANKS; i++) {
        const y = VERTICAL_MARGIN + i * CELL_SIZE;
        const line = el('line', {
          x1: HORIZONTAL_MARGIN,
          y1: y,
          x2: HORIZONTAL_MARGIN + BOARD_WIDTH,
          y2: y,
          stroke: 'ButtonBorder'
        });
        gridLayer.appendChild(line);
      }

      // 九宫格对角线
      const addDiagonal = (x1, y1, x2, y2) => {
        const line = el('line', {
          x1, y1, x2, y2,
          stroke: 'ButtonBorder'
        });
        gridLayer.appendChild(line);
      };

      const x3 = HORIZONTAL_MARGIN + 3 * CELL_SIZE;
      const x5 = HORIZONTAL_MARGIN + 5 * CELL_SIZE;
      const y0 = VERTICAL_MARGIN;
      const y2 = VERTICAL_MARGIN + 2 * CELL_SIZE;
      const y7 = VERTICAL_MARGIN + 7 * CELL_SIZE;
      const y9 = VERTICAL_MARGIN + 9 * CELL_SIZE;

      // 黑方九宫格
      addDiagonal(x3, y0, x5, y2);
      addDiagonal(x5, y0, x3, y2);
      // 红方九宫格
      addDiagonal(x3, y7, x5, y9);
      addDiagonal(x5, y7, x3, y9);

      svg.appendChild(gridLayer);

      // 楚河汉界
      const riverY = VERTICAL_MARGIN + 4 * CELL_SIZE;
      const rect = el('rect', {
        x: HORIZONTAL_MARGIN,
        y: riverY,
        width: BOARD_WIDTH,
        height: CELL_SIZE,
        fill: 'Field'
      });
      riverLayer.appendChild(rect);

      const text = el('text', {
        x: HORIZONTAL_MARGIN + BOARD_WIDTH / 2,
        y: riverY + CELL_SIZE / 2,
        'font-size': FONT_SIZE,
        'text-anchor': 'middle',
        'dominant-baseline': 'middle',
        fill: 'FieldText'
      });
      text.textContent = "楚 河 汉 界";
      riverLayer.appendChild(text);

      svg.appendChild(riverLayer);
      svg.appendChild(pathLayer);
      svg.appendChild(pieceLayer);

      // 绘制初始棋子
      drawPieces();

      // 添加棋盘点击事件
      svg.addEventListener('click', handleBoardClick);
    }

    // 绘制棋子
    function drawPieces() {
      const pieceLayer = document.getElementById('pieces');
      pieceLayer.innerHTML = '';

      pieces.forEach(p => {
        const pos = toSVGPos(p.col, p.row);
        const g = el('g', {
          'data-pos': `${p.col},${p.row}`,
          transform: `translate(${pos.x},${pos.y})`
        });

        const circle = el('circle', {
          r: RADIUS,
          fill: 'Field',
          stroke: 'FieldText'
        });

        const text = el('text', {
          'font-size': FONT_SIZE,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          fill: p.color === 'black' ? 'FieldText' : p.color
        });
        text.textContent = p.name;

        g.appendChild(circle);
        g.appendChild(text);

        g.addEventListener('dblclick', () => {
          // 从数组中移除棋子
          const index = pieces.findIndex(piece => piece.col === p.col && piece.row === p.row);
          if (index !== -1) {
            pieces.splice(index, 1);
          }
          g.remove();
        });
        pieceLayer.appendChild(g);
      });
    }

    // 处理棋盘点击事件
    function handleBoardClick(event) {
      const svg = document.getElementById('chessboard');
      const point = svg.createSVGPoint();
      point.x = event.clientX;
      point.y = event.clientY;
      const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());

      const { col, row } = fromSVGPos(svgPoint.x, svgPoint.y);

      // 检查点击位置是否在棋盘范围内
      if (col < 1 || col > NUM_FILES || row < 1 || row > NUM_RANKS) {
        return;
      }

      // 检查点击位置是否有棋子
      const clickedPiece = pieces.find(p => p.col === col && p.row === row);

      if (clickedPiece) {
        // 点击了棋子，选中它
        selectPiece(clickedPiece);
      } else if (selectedPiece) {
        // 点击了空交叉点且有棋子被选中，移动棋子
        moveSelectedPiece(col, row);
      }
    }

    // 选中棋子
    function selectPiece(piece) {
      // 清除之前选中的棋子
      clearSelection();

      // 设置新选中的棋子
      selectedPiece = piece;

      // 高亮显示选中的棋子
      const pieceElements = document.querySelectorAll('#pieces g');
      pieceElements.forEach(element => {
        const pos = element.dataset.pos.split(',').map(Number);
        if (pos[0] === piece.col && pos[1] === piece.row) {
          const circle = element.querySelector('circle');
          circle.setAttribute('stroke', 'LinkText');
        }
      });
    }

    // 清除选中状态
    function clearSelection() {
      if (!selectedPiece) return;

      const pieceElements = document.querySelectorAll('#pieces g');
      pieceElements.forEach(element => {
        const circle = element.querySelector('circle');
        circle.setAttribute('stroke', 'FieldText');
        // circle.setAttribute('stroke-width', '1');
      });

      selectedPiece = null;
    }

    // 移动选中的棋子
    function moveSelectedPiece(toCol, toRow) {
      if (!selectedPiece) return;

      // 检查目标位置是否为空
      if (hasPieceAt(toCol, toRow)) {
        return;
      }

      // 更新棋子数组中的位置
      const pieceIndex = pieces.findIndex(p => p.col === selectedPiece.col && p.row === selectedPiece.row);
      if (pieceIndex === -1) return;

      const oldCol = selectedPiece.col;
      const oldRow = selectedPiece.row;

      pieces[pieceIndex].col = toCol;
      pieces[pieceIndex].row = toRow;

      // 更新DOM中的棋子位置
      const pieceElement = document.querySelector(`#pieces g[data-pos="${oldCol},${oldRow}"]`);
      if (!pieceElement) return;

      pieceElement.dataset.pos = `${toCol},${toRow}`;
      const newPos = toSVGPos(toCol, toRow);
      pieceElement.setAttribute('transform', `translate(${newPos.x},${newPos.y})`);

      // 清除选中状态
      clearSelection();
    }

    function drawPaths() {
      const pathLayer = document.getElementById('paths');
      pathLayer.innerHTML = '';
      currentPaths = parsePaths(document.getElementById('pathInput').value);

      currentPaths.forEach(path => {
        const p1 = toSVGPos(path.c1, path.r1);
        const p2 = toSVGPos(path.c2, path.r2);
        const line = el('line', {
          x1: p1.x,
          y1: p1.y,
          x2: p2.x,
          y2: p2.y,
          stroke: 'LinkText',
          'stroke-dasharray': '5,5',
          'stroke-width': '2'
        });
        pathLayer.appendChild(line);
      });
    }

    function hasPieceAt(col, row) {
      return pieces.some(p => p.col === col && p.row === row);
    }

    function movePieces() {
      const moves = parsePaths(document.getElementById('pathInput').value);

      for (const move of moves) {
        if (!hasPieceAt(move.c1, move.r1)) break;
        if (hasPieceAt(move.c2, move.r2)) break;

        // 更新棋子数组中的位置
        const pieceIndex = pieces.findIndex(p => p.col === move.c1 && p.row === move.r1);
        if (pieceIndex === -1) continue;

        const piece = pieces[pieceIndex];
        piece.col = move.c2;
        piece.row = move.r2;

        // 更新DOM中的棋子位置
        const pieceElement = document.querySelector(`#pieces g[data-pos="${move.c1},${move.r1}"]`);
        if (!pieceElement) continue;

        pieceElement.dataset.pos = `${move.c2},${move.r2}`;
        const newPos = toSVGPos(move.c2, move.r2);
        pieceElement.setAttribute('transform', `translate(${newPos.x},${newPos.y})`);
        pieceElement.dataset.pos = `${move.c2},${move.r2}`;
      }
    }

    initChessboard();
  </script>
</body>

</html>
